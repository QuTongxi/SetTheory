## 集合论
> 作者：曲桐希
### 0 预备知识   
在高中，你应该学习过以下知识点：
- 描述集合的方法：自然语言表示，列举法，描述法
- 集合的分类：有限集，无限极，空集
- 常用集合：自然数集，整数集，实数集
- 子集和真子集的概念
- 集合运算：交，并，补
- 一些简单的集合公式，比如A的补集的补集是它自身
- 数子集个数

您应该掌握“小学二年级”的数学内容：
> 小学二年级： 仲盛老师用于形容某些小时候就应该学过的数学知识时会描述为“这是小学二年级知识点，不知道的借本小学教材看一看。”

### 1 什么是集合
#### 1.1 类与集合
我们介绍过很多集合的性质，但是对于什么是集合，高中课本上对集合的描述为“一般的，我们把研究对象统称为元素，把一些元素组成的总体叫作集合”[1]，或者我们可能把集合理解成一个装着一些东西的盒子。但当我们真的这样定义集合的时候。我们将陷入巨大的麻烦之中！
**罗素悖论（ Russell Paradox）**：定义一个集合如下：$S = \{ x | x \notin x\} $，也就是说，把一个集合定义为不包含自身作为元素的所有集合的集合，那么$S \in S$吗？
- 如果$S\in S$，根据S的定义，S不包括这样的集合，所以$S\notin S$
- 如果$S\notin S$，根据S的定义，S应该包括这样的集合，所以$S\in S$

这样的集合不存在与这样的集合是空集是两个概念！假如S是空集，空集不是空集的元素，所以$S\notin S$，所以S应该包含空集，这是矛盾的！我们只能说，这样的集合S是不存在的。
与罗素悖论相类似的悖论还有很多：
**说谎者悖论（Liar Paradox）**：这句表述是错误的。
如果这句话本身是错的，那这句话就是对的；如果这句话是正确的，那么它应该是错误的。这个悖论引发我们对命题的真值与含义的思考，也即命题的含义为真与命题的真值为真可能是不一致的。于是，在公理化数理逻辑中，我们从公理出发，当且仅当该命题可以被证明时其真值为真，一个命题只有在特定的模型和语义下才有含义，详细了解请参考数理逻辑教材。
**理发师悖论（Barber’s Paradox）**：有一个小村子里只有一个理发师，他只给那些不给自己剪头发的人剪头。那么，他给自己理发吗？
**刽子手悖论（Unexpected Hanging Paradox）**：法官对囚犯说：下周七天中，囚犯将在某一天的中午执行绞刑，但囚犯在行刑的当天之前并不能推断出中午一定会行刑。用集合的语言表示如下：
$$D=\{d|如果在星期d行刑，那么在星期d之前都无法推断行刑时间\} $$
那么D集合包含的元素有哪些呢？
囚犯进行了以下推理：如果行刑在最后一天，即前六天没有行刑，那么他在周六下午就可以知道周天要行刑，因此第七天不会行刑。那么行刑只能在前六天，那么周六也不会行刑，因为如果行刑在周六，即前五天都不会行刑，那么他在周五下午就知道行刑只能在周六和周天，而在前面他已经排除了周天，所以行刑只能在周六。以此类推，他发现行刑不能在七天中任何一天。因此，他认为他将不会被执行绞刑。
但对于刽子手而言，他可以先选择在任何一天的中午执行绞刑，因为囚犯确实无法推断出这一天会行刑！
引发上述悖论的原因在于这些集合被描述为具有某种特定性质的元素的整体，所以我们需要限制对元素性质的描述，不是随便什么描述都可以生成一个集合的！
这些悖论表明下面的概括公理（axiom schema of comprehension）是不成立的。
> 在一开始，人们就企图将集合论公理化，就在弗雷格即将完成他从集合论出发建立的纯逻辑的数学体系时，罗素给他写了一封信，信里包含了后来著名的罗素悖论。弗雷格的构建的数学大厦轰然倒塌，他不得不承认，自己的公理是有问题的。

**概括公理（伪）**：如果P是某种性质，那么一定存在集合$Y = \{x:P(x)\}$
但是这种描述事物的方法是很方便且强大的，后来数学家管用这种方法定义出来的东西叫做**类（class）**。类就是具有某种性质的一类元素的整体。
> 类（class）：如果$\phi(x,p_1,...,p_n)$是公式，其中$x$是自由变元，$p_i$是约束变元，我们称$C=\{x:\phi(x,p_1,...,p_n)\} 是一个类。$

显然罗素悖论提到的S只是一个类。对于类S，$S\in S$这个问题不再有意义，因为类S不会是其自身的元素。对于那些会导致罗素悖论的类，我们称其为**真类(proper class)**，所以之后再定义集合的时候要仔细想一想，你定义的东西真的是一个集合吗。
对于集合，我们还有其他的一些要求，比如一个集合的元素不能只有它自己，这个对应的公理是**基础公理或正则公理（Axiom of Regularity）**，这个公理有两种形式上不同但是表达含义是一致说法：
**公理 1.1**
（1）基础公理：$\forall x(x\neq \emptyset \rightarrow \exist y(y \in x \land x \cap y = \emptyset)) $
（2）正则公理：每一个非空集合有$\epsilon - $最小元。
借用这个性质我们可以证明下面一件事情：
**例1.1**
不存在一个无穷的集合序列$\{S_n\}_{n\in \mathcal{N}}$，使得对于所有$n\in \mathcal{N}, S_{n+1}\in S_n$
证明：
采用反证法，假设存在这样的$\{S_n\}$，考察$S=\{S_n|n\in\mathcal{N}\} $，也即S是由$\{S_n\}$的前n项构成的集合。根据基础公理，S中一定存在一个元素$S_x$满足$S_x \in S \land S_x \cap S = \emptyset$
从而，$S_{x+1} \in S_x \in S$，且由于$S_x \cap S = \emptyset $可知$S_{x+1}\notin S_x$
这与序列$\{S_n\}_{n\in \mathcal{N}}$的定义相矛盾！
#### 1.2 集合与关系
**定义 1.1（集合运算）**
**交（intersection）**：$A\cap B = \{x|x\in A \ and \ x\in B\}$
**并（union）**：$A\cup B = \{x|x\in A \ or \ x\in B\}$
**补（complement）**：$A^c = \{x|x\in U \ and \ X\notin A\}$，其中U是全集。
**差（difference）**：$A  \backslash  B =A - B= \{x|x\in A \ and \ X\notin B\}$
交并补这几个操作我们在高中就熟知了，接下来我们重点关注差集的性质。我们可以轻松证明以下两条性质：
**不满足交换律**：$A\backslash B \neq B\backslash A$
**不满足结合律**：$A\backslash (B\backslash C)\neq (A\backslash B)\backslash C$
**定理 1.1 (德摩根律，De Morgan Law)**
对于任意的集合A,B,C，满足：
$$A\backslash (B\cup C)=(A\backslash B)\cap(A\backslash C)$$证明：
对于所有的$x\in A\backslash (B\cup C)$，根据定义，有$x\in A$且$x\notin (B\cup C)$,所以$x\notin B$且$x\notin C$，这样的元素$x$也一定同时满足$x\in A\backslash B, \ x\in A\backslash C$，从而有：
$$A\backslash (B\cup C) \subseteq (A\backslash B)\cap(A\backslash C) $$对于所有的$x\in (A\backslash B)\cap(A\backslash C)$，有$x\in (A\backslash B)$且$ x\in (A\backslash C)$，所以$x\in A， x\notin B， x\notin C$，从而有：
$$(A\backslash B)\cap(A\backslash C)\subseteq A\backslash (B\cup C) $$综上所述，定理成立，即
$$A\backslash (B\cup C)=(A\backslash B)\cap(A\backslash C)$$
**定义1.2 （笛卡尔积， Cartesian product）**
> 笛卡尔（Descartes）是法国数学家，哲学家，物理学家，而笛卡尔积中出现的单词Cartesian是为了纪念笛卡尔对现代科学做出的伟大贡献，将他名字中的“cartes”后面加上“-ian”变为形容词，意为“笛卡尔的”。

$$X \times Y = \{(x,y)|x\in X,y\in Y\} $$**例1.2**下面举出两个例子来辅助理解：
（1）$ X=\{1,2\},  Y=\{2,3,4\},  X×Y=\{(1,2),(1,3),(1,4),(2,2),(2,3),(2,4)\}$
（2）我们在高中就接触过的欧几里得坐标平面（就是有x轴、y轴的那个平面）的实质就是两个数轴的笛卡尔积，也可以表示为数轴的平方（square），记为$P = \mathcal{R}^2 $。
在介绍笛卡尔积的时候，出现了一个新的符号$(x,y)$，这个东西称为**有序对**（ordered pair），与集合的区别在于其有序性，也即$(x,y)\neq (y,x)$.
**定义1.3 （有序对）**
$$(x,y)=\{\{x\},\{x,y\} \} $$其中一个元素是另一个元素的子集，这样两个元素的先后顺序就被记录下来了.这样定义了有序对之后，我们就可以避免对“有序”的不正规的描述了。集合的重要性在于它是现代数学的基石，数学上几乎所有的事物都可以看做集合。
**定义1.4 （n个集合的笛卡尔积)**
$$X_1×X_2×...×X_n=\{(x_1,x_2,...,x_n)|x_1\in X_1,...,x_n\in X_n \} $$显然，这个操作不满足交换律，但是满足结合律。有了有序对，就是二元组的正式定义之后，我们是这样定义n-元组的：
$$\begin{align*}
    (a,b,c) &= ((a,b),c)\\
    (a,b,c,d) &= ((a,b,c),d)\\
    &\cdots\\
    (a_1,...,a_{n+1})&=((a_1,...,a_n),a_{n+1})
\end{align*} $$“有序”意味着当且仅当$a_1=b_1,...,a_n=b_n$，我们才认为$(a_1,...,a_n)$与$(b_1,...,b_n) $是相等的。
当我们对同一个集合做n次笛卡尔积时，我们可以简单的将其记为某个集合的n次幂的形式，例如$\mathcal{R}\times\mathcal{R}=\mathcal{R}^2$表示欧几里得平面，$\{0,1\}^n$表示一个长度为n的比特串。
> 或许你可能会想，那我能不能将笛卡尔积拓展到无穷项，或者无穷个集合的交、并表示什么。从有限到无穷并不是一个简单的过程，我们暂时也不会去研究就这些问题。

**定义1.5 （二元关系，binary relation）**
<center>一个有序数组的集合叫做一个二元关系。</center>

比如我们上文提到的由笛卡尔积生成的集合就是一个二元关系。
我们说**X上的关系**（a relation on X），是指集合中所有有序对的两个元素都来自于同一个集合X。类似的，我们可以定义**n元关系**，即一个n-元组的集合称为n元关系，在大多数情况下，我们把二元关系简称为**关系**（relations）。对于X上的关系R，如果$(a,b)\in R$，那们我们也可以表示为$a \ R \ b$
> 注意，在这里关系既指一种集合元素之间运算，比如“大于”，“等于”这种运算本身，又指通过这种运算生成的集合。在{1，2，3}上定义的小于关系就是$ \{(1,2),(2,3),(1,3)\} $。因为1<2,  2<3,  1<3.

**定义1.6 （关系的性质）**
令R是集合X上的关系：
（1）R是**自反的**（reflexive），若对于任意的$a\in X$，有$(a,a)\in R$
（2）R是**对称的**（symmetric），若$(a,b)\in R\rightarrow (b,a)\in R$
（3）R是**反对称的**（antisymmetric），若$(a,b)\in R\land (b,a)\in R\rightarrow a=b $
（4）R是**强反对称的**（strongly antisymmetric），若$(a,b)\in R\rightarrow (b,a)\notin R$ 
**例1.3**对于X={1，2，3}，分别给出一个满足自反性，对称性，反对称性和强反对称性的关系。
解：
（1）对于自反性，需要注意是对X中所有的元素都要成立，比如$\{(1,1),(2,2),(3,3)\}$就是一个自反的关系。
（2）对称性不要求X中所有元素都满足，关系$\{(1,2),(2,1)\}$就是一个对称的关系。
（3）（4）注意反对称和强反对称的差别，与对称性完全相反的表述是强反对称性，即$(a,b)$在R中那么$(b,a)$一定不在，而反对称说的是，当a,b不相同时$(a,b)$在那么$(b,a)$一定不在，而$(a,a)$是可以包含的。例如X上的$\leq $关系  $\{(1,1),(1,2),(1,3),(2,2),(2,3),(3,3) \}$是反对称的，而$< $关系 $\{(1,2),(1,3),(2,3)\}$是强反对称的。
**定义1.7 传递性（transtive）**
集合X上的关系R具有传递性，若：
$$(a,b)\in R\land (b,c)\in R\rightarrow (a,c)\in R $$在上文中提到的$\leq $关系、$< $关系都具有传递性，由于传递性，我们自然可以列出一个长链，比如：$1<2<3<4<5<\cdots$，对于这个链中的元素，我们按顺序任选两个，它们组成的有序对都应该属于<关系。对于X上的某一个传递的关系R，我们希望通过添加有序对的方式得到一个具有传递性的新集合，且得到的集合为包含有给定关系R的最小传递关系，这个新的集合称为R的**传递闭包**（transtive closure），它的正式定义如下：
> 这里所说的某个传递关系R不是指R本身是传递的，而是说对于某个R，使它具有传递性,然后研究得到的$R^\star$。可以研究传递闭包是因为不会有关系R是无法添加传递性的，相类似的，我们有自反闭包和对称闭包，但没有反对称闭包。

**定义1.8 （传递闭包）**
$$R^{\star}=R\cup \{(a,b)|\exist c_1,...,c_k  \ s.t. \ (a,c_1),(c_1,c_2),...,(c_{k-1},c_{k}),(c_{k},b)\in R \} $$一个朴素的想法就是遍历R，对于R中每个有序对中的元素c，当寻找到$(a,b), (a,c)$时就添加一个$(b,c)$，然后一轮一轮不断寻找下去，直到不再添加元素为止。
> 简单分析一下正确性：
> 对于定义，$(a,c_2)$在第一轮就被加入算法，因为$(a,c_1)$原来就有，在第二轮，显然$(a,c_3)$可以被加入到算法中，这样我们通过有限轮的运算后，就可以得到$(a,b)$了。

但是这个算法效率并不是很高。假设输入的集合有N个元素，那么我们需要至多N-2轮算法来确保所有的(a,b)都被加入到集合中。而对于每一轮，需要遍历集合来寻找所有可能的a，b，c，这需要$N^3$步，从而整个算法需要$N^4-2N^3$步操作才能完成。接下来我们将介绍一个更快的算法。
> 在算法课上我们会引入时间复杂度的概念来衡量一个算法的效率，这个朴素想法的时间复杂度是$O(N^4)$的。

**定义1.9 （沃舍尔算法，Warshall Algorithm）**
> 斯蒂芬·沃舍尔（Stephen Warshall），1935-2006，美国计算机科学家。1956年，沃舍尔毕业于哈佛大学，获得数学学士学位，但由于在当时缺少他感兴趣领域的研究生课程，因此没有获得更高学位。沃舍尔曾经为了他的算法的正确性与朋友打赌，最终获得了一瓶朗姆酒。
> 
沃舍尔算法从头开始遍历集合X每一个元素，对于元素i，如果(a,i)和(i,b)都在R中，则将(a,b)加入R。
如果我们用一个矩阵表示关系R，即对于$X=\{x_1,x_2,...,x_n\}$上的关系R，如果$x_i R x_j$（也就是说$(x_i,x_j)\in R$），则将矩阵M(R)的第i行第j列的值设为1，否则设0.这样得到的矩阵成为**关系矩阵**。
**例1.4 （关系矩阵）**
对于例1.3中的X和<关系，对应的关系矩阵如下：
$$\begin{pmatrix}
    0 & 1 & 1\\
    0 & 0 & 1\\
    0 & 0 & 0
\end{pmatrix} $$
用关系矩阵重新描述沃舍尔算法的内容如下：
- 判断关系矩阵的每一行第一个元素是否为1，若为1，则将该行每个元素与第一行的元素逐个做或运算的结果作为该行该元素的新值。
- 结束后，判断第二个元素是否为1，若为1，将该行每个元素与第二行的元素逐个做或运算的结果作为该行该元素的新值。
- 依此类推

**例1.5 （沃舍尔算法运行过程）**
$X=\{1,2,3,4,5\}, \ R=\{(4,2),(2,1),(1,3),(3,5) \} $,观察(4,5)是怎样被添加进来的。
- 检查元素1，寻找(a,1)和(1,b):  (2,3)被添加进来，因为(2,1)和(1,3)在R中。
- 检查元素2，寻找(a,2)和(2,b): (4,3)被添加进来，因为(4,2)和(2,3)在R中。
- 检查元素3，寻找(a,3)和(3,b): (4,5)被添加进来，因为(4,3)和(3,5)在R中。
> 当然算法还要继续，且每一步可以添加不只一个元素，比如第2步时(4,1)也被添加了，上面的步骤只是为了展示(4,5)的添加。

**推论1.1 （时间复杂度）**
沃舍尔算法的时间复杂度为$O(N^3)$，通俗来讲，即只需要$N^3$数量级的步数就可以完成传递闭包的计算。
证明：沃舍尔算法遍历一次集合需要N步操作，每一次需要寻找a和b两个值，不同的a、b组合有$N^2$个，所以需要$N^2$步，综上所述，沃舍尔算法需要$N^3$步就可以计算出传递闭包。
**定义1.10** 等价关系（equivalence relations）
 <center>X上的关系R是等价关系，当且仅当R是自反的，传递的，对称的。</center>

**例1.6** 证明同余关系是等价关系。
- 自反性：就是说自己和自己是同余的，这显然成立。
- 传递性：a和b同余，b和c同余，所以a和c同余。这个在我们“小学二年级”学带余数除法的时候就知道了，因为a,b,c都是除数的某个倍数加上余数。
- 对称性：a和b同余，则b和a也同余。

**例1.7** 大于关系、大于或等于关系不是等价关系。
对于不相同的两个元素a、b，大于和大于或等于关系都不满足对称性。即a > b和b > a不能同时成立, a $\ge$ b和b $\ge$ a不能同时成立。
**定义 1.11**（划分，partition）
X的一个划分P是一个只包含X的子集的集合，且满足：
（1）P中任意两个元素是不相交的。
（2）P中所有元素的并集是集合X。
划分P的元素（同时是X的子集）被称为**等价类**（equivalence class）。
**例1.8**（划分）
$X = \{1,2,3,4,5\}$，则$P=\{\{1,2,3\},\{4\},\{5\} \} $是X的一个划分。
**定理1.2**
<center>X上的等价关系R提供了X的一个划分。</center>

证明：   
> 思路：X上有等价关系R，也就是说X中有一些元素是互相等价的，我们将这些互相等价的元素放到一个子集里（如果某个元素只与自己等价，那么我们构造的子集就是只含它自己的单元素集）。这样我们得到的这些子集应该就是一个划分了，接下来我们证明这样的子集满足划分的性质。

令$P = \{\{y|(x,y)\in R\}|x\in X\}$即对于元素x，与其有等价关系(x,y)的所有y被放到一个集合里。
首先证明P中元素不交：
取$p,\ p^\prime\in P \ (p\neq p^\prime)$，假设两者有交集，即$\exist z,\ z\in p=\{y|(x,y)\in R\},\ z\in p^\prime = \{y|(x^\prime,y)\in R\} $。由于$z\in p $则$(x,z)\in R$，$z\in p^\prime $则$(x^\prime,z)\in R$。对于$p^\prime $中任意一个$y^\prime$而言，有$(x^\prime, y^\prime)\in p^\prime $，由于对称性$(z,x^\prime)\in R$，再由传递性，$(x,z),(z,x^\prime),(x^\prime, y^\prime)\in R $，可以得到$(x,y^\prime)\in R $，根据$p $的定义可以知道，$y^\prime\in p $。从而$p^\prime$所有的元素都在$p $中，也即$p^\prime \subseteq p$。对于上文的证明，交换$p,\ p^\prime$的地位，不难证得，$p \subseteq p^\prime$，也即$p=p^\prime$，与最开始的定义矛盾。
然后我们来证明P的所有元素的并是X：
由于P的元素是X的子集，将X的一些子集做并集得到的集合不会含有X以外的元素，从而$\underset{p\in P}{\bigcup}p \subseteq X$。另一方面，R是等价关系，是自反的，对于任意的$x\in X$，有$(x,x)\in R$，从而$x\in \{y|(x,y)\in R\},\ x\in \underset{p\in P}{\bigcup}p $，也即$ X\subseteq \underset{p\in P}{\bigcup}p$，综上$X = \underset{p\in P}{\bigcup}p$
**例1.8** 考虑极限为0的正实数数列构成的集合$X=\{\{a_n\}|\lim_{n\rightarrow\infty}a_n=0 \}$，证明关系$R = \{(\{a_n\},\{b_n\})|\lim_{n\rightarrow\infty}\frac{a_n}{b_n} = 1\}$是一个等价关系。
证明：
显然R是自反的。
对于任意的$(\{a_n\},\{b_n\})\in R$，有$\lim_{n\rightarrow\infty}\frac{a_n}{b_n} = 1$，从而$\lim_{n\rightarrow\infty}\frac{b_n}{a_n} = \frac{1}{\lim_{n\rightarrow\infty}\frac{a_n}{b_n}} = 1$，也即$(\{b_n\},\{a_n\})\in R$，所以R是对称的。
如果$(\{a_n\},\{b_n\})\in R,\ (\{b_n\},\{c_n\})\in R$，则$\lim_{n\rightarrow\infty}\frac{a_n}{c_n}=\lim_{n\rightarrow\infty}\frac{a_n}{b_n}\cdot\frac{b_n}{c_n}=\lim_{n\rightarrow\infty}\frac{a_n}{b_n}\cdot\lim_{n\rightarrow\infty}\frac{b_n}{c_n}=1$，所以R是传递的。
事实上，R在衡量数列的递减速率，$\{1/n\}$和$\{2/(2n+1)\} $在一个等价类中，而$\{1/2n\}$不在它们的等价类中，因为$\{1/2n\}$的递减速率是$\{1/n\}$的2倍。
> 具体了解“递减速率”的概念请参考数学分析。

####1.3 映射与函数
高中的定义：
> 关于定义域、像集的符号并没有统一的规定，不同的书上符号不同是很正常的。

设A和B是两个非空集合，我们说$f$是一个从A到B的**映射**（mapping）或**函数**（function），若对于任意的$x\in A$，存在$f(x)\in B$，记为$f: A\rightarrow B$。A被称为$f$的**定义域**（domain），记为$dom(f)$，B被称为$f$的**值域**（codomain），$\{f(x)|x\in A\}$为$f$的**像集**（range），记为$rng(f)$。
使用集合论的语言，我们可以这样定义一个函数：
**定义1.12** （函数）
设A和B是两个非空集合，我们说$f$是一个从A到B的**映射**（mapping）或**函数**（function），若在集合A和B之间存在一个二元关系R，且对于任意的$x\in A$，存在唯一的$y\in B$使得$(x,y)\in R$.
**定义 1.13**
（1）映射$f: A\rightarrow B$是一个**单射**(one-to-one)，若对于任意的$x,y\in A(x\neq y)$有$f(x)\neq f(y)$.
（2）映射$f: A\rightarrow B$是一个**满射**(onto)，若$f$的像集就是它的值域。
（3）映射$f: A\rightarrow B$是一个**双射**（或**一一映射**）(bijection)，若$f$既是单射，也是满射。
> 注意：不要把one-to-one当成一一映射，外国人一般用bijection来形容一一映射。

**定义1.14** （反函数，inverse function）
若$f$是一个双射，则定义$f$的反函数（或逆映射）$f^{-1}:B\rightarrow A$如下：
$$f^{-1}(y) = x \ \mathrm{iff} \ f(x)=y$$
> iff是当且仅当的意思。

注意到双射是一种特殊的映射，但有时我们可能会需要研究一个任意的映射的逆，因此我们在某些需要的情境下定义**广义反函数**（generalized inverse function）。
>例子：在线性代数中，矩阵A可以视为线性变换(函数),将每个矢量映射到另一个矢量。它的逆矩阵（如果有）表示逆变换。然而，当矩阵为奇异的，我们可以定义它的广义逆矩阵作为矩阵G，使得AGA＝A。

**定义1.15**（函数复合）
设$f:A\rightarrow B, \ g: B\rightarrow C$，将$f$和$g$复合后得到函数$h$，记为$h=f\circ g$，对任意的$x\in A, \ h(x) = g(f(x))$.
> 注意 f 和 g 的顺序。

- 如果f和g都是单射，则h也是单射
- 如果f和g都是满射，则h也是漫射
- 如果f和g都是双射，则h也是双射
- 如果h是单射，则f一定是单射，g不一定
- 如果h是满射，则g一定是满射，f不一定
- 如果h是双射，则f和g可能都不是双射

**泛函与函数式编程**
**定义1.16**（泛函，functional）
$f:A\rightarrow B$是一个**泛函**（或**算子**），若A和B中至少有一个是函数集合。
> 比如导数算子$\frac{d}{dx}$是一个泛函，因为它将函数映射为其导数。

**函数式编程**图灵（Turing）发现，$\lambda$演算是图灵完备的，从而一个算法可以表示为一个函数或泛函。












